---
  author: "Ferando Alberto Miranda Bonomi"
  title: "Lenguaje C"
  date: last-modified
  date-format: iso
  format: pdf
  monofont: "Hack"
  monofontoptions: Scale=.8
  lang: es
  number-sections: true
  code-line-numbers: true
  bibliography: bibliografia.bib
---

## Lenguaje de programación {#sec-lenguaje-de-programacion}

Es un lenguaje formal que permite codificar procesos de cómputo o algoritmos de manera que puedan ser ejecutados por una computadora.

### Un ejemplo {#sec-exm-sumatoria}

Como ejemplo veremos la implementación en lenguaje C y ensamblador de un algoritmo simple con la siguiente especificación:

::: {#exm-sumatoria}
Implementar una función que permita *sumar un arreglo de enteros con signo de 32 bit usando aritmética con signo de 64 bit y produciendo un resultado de 64 bit*.
:::

El @lst-sumatoria-h es un encabezado en lenguaje C que describe la función sumatoria que implementa la solución. Tanto la implementación en C como ensamblador respetarán esta interfaz. (ver @sec-encabezados)

El @lst-sumatoria-main presenta un programa en C que *prueba la solución*. Este código define un arreglo de números a sumar (líneas 5 y 6). Calcula la suma usando la función sumatoria especificada en el @exm-sumatoria (línea 8). Comprueba que el resultado obtenido sea el correcto (línea 10). Presenta en pantalla el resultado (línea 12) y termina el programa retornando el código `0` al sistema operativo (que indica que terminó correctamente). Si el resultado no fuera el esperado `assert` termina la ejecución del programa indicando un error.

:::{.callout appearance="minimal"}
::::{#lst-sumatoria-h lst-cap="sumatoria.h"}
``` {.c }
#ifndef SUMATORIA_H /* Compilación condicional para impedir*/
#define SUMATORIA_H /* doble inclusión del contenido*/
#include <stdint.h> /* Este encabezado estandar define intxx_t*/
/* Declaración de la función */
int64_t sumatoria(int32_t cantidadDeNumeros, int32_t const numeros[]);
#endif

```
::::
:::

:::{.callout appearance="minimal"}
::::{#lst-sumatoria-main lst-cap="main.c" }
``` {.c }
#include <assert.h>    /* assert */
#include <stdio.h>     /* printf */
#include <sumatoria.h> /* sumatoria */
int main(void){
  static int32_t const numeros[] = {0x7F00AA00,1983,775,0x45678901};
  static unsigned const cantidadDeNumeros = sizeof(numeros)/sizeof(numeros[0]);
  /* Calcula la suma */
  int64_t const suma = sumatoria(cantidadDeNumeros,numeros);
  /* Comprueba que el resultado sea el esperado */
  assert(((int64_t)0x7F00AA00 + 1983 + 775 + 0x45678901) == suma);
  /* Presenta el resultado en pantalla */
  printf("La suma es %ld y coincide con lo esperado.\n",suma);
}

```
::::
:::

::: callout-important
El lenguaje C distingue mayúsculas y minúsculas.
:::

#### Implementación en lenguaje C {#sec-exm-sumatoria-c}

El @lst-sumatoria-c contiene la implementación en lenguaje C del @exm-sumatoria. La línea 1 incluye el encabezado del @lst-sumatoria-h, que declara la función sumatoria. En las líneas 2 a 9 se define o implementa la función sumatoria. El cuerpo de la función es el bloque de código que inicia con la llave en la línea 3 y termina con la llave en la línea 9. La línea 4 define la variable automática `acumulador` con un valor inicial de cero. Las líneas 5 a 7 contienen una estructura de repetición `for` que recorre el arreglo `numeros`, toma cada valor, convirtiéndolo de tipo `int32_t` a tipo `int64_t` (es una conversión implícita, ver @sec-promocion-enteros) y lo suma al valor de la variable `acumulador`, guardando el resultado en la misma variable `acumulador`. Finalmente la sentencia `return` de la línea 8 finaliza la función y retorna el valor de la variable `acumulador` como valor de la función.

:::{.callout appearance="minimal"}
::::{#lst-sumatoria-c lst-cap="sumatoria.c"}
``` {.c }
#include <sumatoria.h>
int64_t sumatoria(int32_t const cantidadDeNumeros,
                  int32_t const numeros[const]){
  int64_t acumulador = 0;
  for (int i=0;i < cantidadDeNumeros;++i){
    acumulador += numeros[i];
  }
  return acumulador;
}

```
::::
:::

#### Implementación en ensamblador ARMv7-M {#sec-exm-sumatoria-asm}

El @lst-sumatoria-asm presenta la implementación del @exm-sumatoria en ensamblador ARMv7-M.

:::{.callout appearance="minimal"}
::::{#lst-sumatoria-asm lst-cap="sumatoria.s"}
```{.asm }
  .syntax unified
  .thumb
  .cpu cortex-m3
  .fpu softvfp
  .arch armv7-m

  .section  .text.sumatoria,"ax",%progbits
  .global  sumatoria
  .type  sumatoria, %function
sumatoria:
  cmp  r0, #0
  ble  .L4
  movs  r2, #0
  movs  r3, #0
  subs  r1, r1, #4
  push  {r4}
  add  r4, r1, r0, lsl #2
.L3:
  ldr  r0, [r1, #4]!
  adds  r2, r2, r0
  adc  r3, r3, r0, asr #31
  cmp  r1, r4
  bne  .L3
  mov  r0, r2
  mov  r1, r3
  pop  {r4}
  bx  lr
.L4:
  movs  r2, #0
  movs  r3, #0
  mov  r0, r2
  mov  r1, r3
  bx  lr
  .size  sumatoria, .-sumatoria

```
::::
:::


#### Código máquina {#sec-exm-sumatoria-machine-code}

:::{.callout appearance="minimal"}
::::{#lst-sumatoria-dump lst-cap="Volcado de memoria del símbolo *sumatoria*"}

``` {.hex  code-line-numbers="false"}
  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 	
08000340: 00 28 10 DD 10 B4 04 39 01 EB 80 00 00 22 00 23   .(.Ý.´.9.ë...".#
08000350: 51 F8 04 4F 12 19 43 EB E4 73 81 42 F8 D1 10 46   Qø.O..Cëäs.BøÑ.F
08000360: 19 46 10 BC 70 47 00 22 00 23 10 46 19 46 70 47   .F.¼pG.".#.F.FpG
```
::::
:::

:::{.callout appearance="minimal"}
::::{#lst-sumatoria-disassemble lst-cap="Desensamblado de *sumatoria*"}
``` {.hex code-line-numbers="false"}
08000340 <sumatoria>:
 8000340:       2800            cmp     r0, #0
 8000342:       dd10            ble.n   8000366 <sumatoria+0x26>
 8000344:       b410            push    {r4}
 8000346:       3904            subs    r1, #4
 8000348:       eb01 0080       add.w   r0, r1, r0, lsl #2
 800034c:       2200            movs    r2, #0
 800034e:       2300            movs    r3, #0
 8000350:       f851 4f04       ldr.w   r4, [r1, #4]!
 8000354:       1912            adds    r2, r2, r4
 8000356:       eb43 73e4       adc.w   r3, r3, r4, asr #31
 800035a:       4281            cmp     r1, r0
 800035c:       d1f8            bne.n   8000350 <sumatoria+0x10>
 800035e:       4610            mov     r0, r2
 8000360:       4619            mov     r1, r3
 8000362:       bc10            pop     {r4}
 8000364:       4770            bx      lr
 8000366:       2200            movs    r2, #0
 8000368:       2300            movs    r3, #0
 800036a:       4610            mov     r0, r2
 800036c:       4619            mov     r1, r3
 800036e:       4770            bx      lr
```

::::
:::

## El lenguaje de programación C {#sec-lenguaje-c}

El lenguaje C es un lenguaje de programación de alto nivel, compilado, imperativo, estructurado y procedimental.

-   Es un lenguaje de *alto nivel*, porque codifica procesos en forma independiente del hardware donde se ejecutarán.
-   Es un lenguaje *compilado*, porque el código fuente es traducido a código máquina antes de su ejecución.
-   Es un lenguaje *Imperativo*, el programa está escrito en forma de *sentencias* o instrucciones a ejecutar. Especifica *como hacer*.
-   Es un lenguaje *Estructurado*, porque la secuencia en que se ejecutan las sentencias es determinada por estructuras de control: estructuras secuenciales (bloques de código), estructuras de selección (if, switch) y estructuras de repetición (while, do..while, for).
-   *Procedimental*, el código está organizado en procedimientos o funciones.

### El proceso de compilación en C {#sec-compilacion}

La @fig-compilacion presenta un esquema del proceso de compilación del lenguaje C. Es el proceso por el cual el código fuente escrito en un lenguaje compilado es convertido en código máquina ejecutable. El código fuente se encuentra distribuido en diversos archivos fuente de extensión `.c` y archivos de encabezado con extensión `.h`. Un archivo fuente junto con todos los encabezados incluidos en el mismo constituye una *unidad de traducción*. La compilación de una unidad de traducción da lugar a un archivo de *código objeto*, de extensión `.o`, que contienen código máquina donde las direcciones de memoria no son fijas sino definidas mediante variables denominadas símbolos. Los archivos objeto pueden consolidarse en archivos de librería de extensión `.a`, análogos a los archivos `.zip` pero especializados para organizar código objeto. El archivo ejecutable es creado organizando el código objeto y dando valores concretos a los símbolos mediante un proceso denominado enlazado. 

:::{.callout appearance="minimal"}
![Proceso de compilación](proceso_compilacion.png){#fig-compilacion fig-align="center"}
:::

### El Preprocesador {#sec-preprocesador}

Es un procesador de texto automático. Procesa los *comentarios* y las *directivas del preprocesador*, su salida es la entrada del compilador de C. En el @lst-parpadeo-c vemos un programa simple que parpadea el LED integrado en una placa de desarrollo. Vamos a usarlo para ilustrar algunas funciones del preprocesador.

Un comentario es todo texto entre `/*` y `*/` o entre `//` y el fin de línea. El preprocesador elimina los comentarios, reemplazándolos por un espacio en blanco. Podemos observar múltiples comentarios. En las líneas 4 y 10 hay comentarios que comienzan en `//`, que es un estilo de comentario originado en C++ y luego adoptado también por C. Los demás comentarios son delimitados por `/*` y `*/`, que es el estilo original de C. Estos comentarios pueden intercalarse en el código en cualquier parte donde pueda ponerse un espacio en blanco (ej. comentarios en líneas 12 y 14). Además pueden abarcar múltiples líneas (ej. comentario en líneas 5 a 7).

Las directivas del preprocesador comienzan con un caracter numeral (`#`), que debe ser el primer caracter de la línea y continúan hasta el final de línea. Pueden prolongarse en varias líneas escapando las nuevas líneas con el caracter barra invertida (`\`). En la línea 2 observamos la directiva `#include`, que inserta el contenido del archivo indicado (usualmente un archivo de encabezado, `.h`) en el punto donde se encuentra la directiva antes de continuar el procesamiento. La directiva `#define` en la línea 4 define una *macro del preprocesador* que sustituye la *palabra* "TIEMPO_MILISEGUNDOS" por "500".


:::{.callout appearance="minimal"}
::::{#lst-parpadeo-c lst-cap="parpadeo.c"}
```{.c}
/* Incluye el encabezado que declara todo lo que comienza por SP_ */
#include <soporte_placa.h> 
/* Define una macro del preprocesador */
#define TIEMPO_MILISEGUNDOS 500 // comentario estilo C++
/* Comentario de
 * varias líneas
 */
int main(void)
{ /* un comentario */
  bool estado=0; // otro comentario
  SP_init();
  SP_Pin_setModo(SP_PIN_LED /*handle pin*/,SP_PIN_MODO_SALIDA /*modo*/);
  while(1){
    SP_Pin_write(SP_PIN_LED,estado /*valor*/ );
    SP_Tiempo_delay(TIEMPO_MILISEGUNDOS);
    estado = !estado;
  }
  return 0;
}
```
::::
:::


#### Mas sobre inclusiones {#sec-include}

Las directivas `#include` son reemplazadas por el contenido de otro archivo. Luego el procesamiento continúa desde la primera línea insertada.

`#include <archivo.h>` : inserta el contenido de *archivo.h* en este punto antes de continuar. Busca *archivo.h* en los directorios de encabezados de librerías.  
`#include "archivo.h"` : igual que el anterior, pero busca *archivo.h* también en el directorio actual.

#### Mas sobre macros {#sec-macros}

Las macros permiten definir palabras de modo que cuando el preprocesador las encuentra son sustituídas por la definición en forma *literal* (copiando y pegando la definición en el punto donde estaba la palabra). Es convención casi universal escribir los nombres de las macros en MAYUSCULAS, separando las partes por guión bajo si el nombre es compuesto. La definición de la macro termina al terminar la línea, sin embargo es posible definir macros de múltiples líneas para mejor legibilidad si se escapa con barra invertida el salto de línea (se escribe `\` inmediatamente antes de hacer el salto de línea). Las macros deben definirse en un encabezado si es que son utilizadas en más de un archivo fuente (**no repetir definiciones**).

`#define MACRO_1 123` : define una macro del preprocesador. En adelante cualquier ocurrencia de MACRO_1 es reemplazada por 123.  
`#define MACRO_1 (1+44)` : si el valor de una macro es una expresión **debe ir encerrado en paréntesis** puesto que las macros efectúan sustitución literal.

Existen también macros con parámetros, llamados *macros tipo función*. Estas macros se definen incluyendo una lista de parámetros pegada a la palabra (*sin espacios entre la lista y la palabra*). Estas macros se usan como si fuesen funciones de C, pero en lugar de ser un llamado a función el preprocesador las reemplaza por su definición. Dentro de la definición los parámetros son reemplazados por los valores indicados al usar la macro.

El @lst-ejemplo-macros muestra un ejemplo de uso de macros ilustrativo pero no recomendado en la práctica. `PIN_SET` y `PIN_CLEAR` son macros parametrizadas, `ESPERA` es una macro parametrizada que además usa múltiples líneas por claridad e incluye un bloque de código. La estructura do..while ejecuta el bloque exactamente una vez y su función es que sea necesario el punto y coma al final de la línea al usar la macro (para que su comportamiento sea similar a un llamado a función). El @lst-ejemplo-macros-expansion muestra la función main luego de la expansión de todas las macros. Pueden también definirse macros mediante argumentos de línea de comandos en la llamada al preprocesador, normalmente `-D<nombre de la macro>=<valor>` por ejemplo `-DCAPACIDAD_COLA=8` define la macro `CAPACIDAD_COLA` con la sustitución `8` antes de iniciar el procesamiento de los archivos.

:::{.callout appearance="minimal"}
::::{#lst-ejemplo-macros lst-cap="Ejemplo de macros (NO ES UN USO RECOMENDADO)"}
```{.c}
#include <stm32f1xx.h>

#define CFG_MODO_SALIDA 0b0010

#define PUERTO_LED GPIOC
#define PUERTO_LED_ENABLE RCC_APB2ENR_IOPCEN
#define PIN_LED 13
#define CR_LED (PUERTO_LED->CRH)
#define OFFSET_CR_LED ((PIN_LED * 4) % 32)
#define PIN_SET(puerto,pin) ((puerto)->BSRR = 1 << (pin))
#define PIN_CLEAR(puerto,pin) ((puerto)->BRR = 1 << (pin))

#define CICLOS_FOR_POR_MILISEGUNDO (8000000/(1000*13))
#define ESPERA(milis) do{\
  for (uint32_t i = (milis); i>0; --i){\
    for (uint32_t volatile j=0;j<CICLOS_FOR_POR_MILISEGUNDO;++j);\
  }\
}while(0)

int main(void){
  RCC->APB2ENR |= PUERTO_LED_ENABLE;
  CR_LED =  (CR_LED & (0xF << OFFSET_CR_LED)) 
          | (CFG_MODO_SALIDA << OFFSET_CR_LED);
  for(;;){
    PIN_SET(PUERTO_LED,PIN_LED);
    ESPERA(500);
    PIN_CLEAR(PUERTO_LED,PIN_LED);
    ESPERA(50*10);
  }
}

```
::::
:::
:::{.callout appearance="minimal"}
::::{#lst-ejemplo-macros-expansion lst-cap="Macros expandidas (lineas quebradas para que el código entre en el espacio)"}
```{.c code-line-numbers="false"}
int main(void){
  ((RCC_TypeDef *)((0x40000000UL + 0x00020000UL) + 0x00001000UL))->APB2ENR |=  ↩
  (0x1UL << (4U));
  (((GPIO_TypeDef *)((0x40000000UL + 0x00010000UL) + 0x00001000UL))->CRH) =    ↩
  ((((GPIO_TypeDef *)((0x40000000UL + 0x00010000UL) + 0x00001000UL))->CRH) &   ↩
  (0xF << OFFSET_CR_LED)) 
          | (0b0010 << ((13 * 4) % 32));
  for(;;){
    ((((GPIO_TypeDef *)((0x40000000UL + 0x00010000UL) + 0x00001000UL)))->BSRR =↩
    1 << (13));
    do{ for (uint32_t i = (500); i>0; --i){ for (uint32_t volatile j=0;        ↩
    j<(8000000/(1000*13));++j); }}while(0);
    ((((GPIO_TypeDef *)((0x40000000UL + 0x00010000UL) + 0x00001000UL)))->BRR = ↩
    1 << (13));
    do{ for (uint32_t i = (50*10); i>0; --i){ for (uint32_t volatile j=0;      ↩
    j<(8000000/(1000*13));++j); }}while(0);
  }
}

```
::::
:::

#### Compilación condicional {#sec-compilacion-condicional}

Las directivas de compilación condicional permiten remover código fuente antes del paso de compilación de acuerdo al valor de una expresión constante (con `#if`) o bien según esté o no definida una macro (con `#ifdef` o `#ifndef`).

`#if expresión` : Incluye un bloque de texto solo si la expresión es verdadera. En la expresión solo pueden particiapr *números y macros del preprocesador*. El bloque termina con `#endif` o `#else`.  
`#else` : Luego de `#if`, termina el bloque `#if` e inicia otro que solo se incluye si el bloque `#if` *no fue incluído*. El bloque termina con `#endif`.  
`#ifdef MACRO` : Incluye un bloque de texto *solo si la macro está definida* (independiente de su valor). El bloque termina en `#endif` o en un bloque `#else ... #endif`.  
`#ifndef MACRO` : Incluye un bloque de texto *solo si la macro **no** está definida* (independiente de su valor). El bloque termina en `#endif` o en un bloque `#else ... #endif`.  
Para complementar la compilación condicional contamos también con la directiva `#error` que permite abortar la compilación indicando un error. Junto con las directivas de compilación condicional permite abortar la compilación si no se cumple un requisito determinado.

El @lst-comp-condicional contiene ejemplos de uso de las directivas de compilación condicional.


:::{.callout appearance="minimal"}
::::{#lst-comp-condicional lst-cap="Ejemplo compilación condicional"}
``` {.c}
#ifndef __STDC_VERSION__
// Es una versión anterior a C99
#define INLINE
typedef bool unsigned char;
#define true 1
#define false 0
#else 
#include <stdbool.h>
#define INLINE inline
#endif // __STDC_VERSION__

#ifndef CAPACIDAD_COLA
#define CAPACIDAD_COLA 8
#endif

#if CAPACIDAD_COLA & (CAPACIDAD_COLA - 1)
#error Solo se soporta capacidad potencia de dos para la cola
#endif
```
::::
:::

### Encabezados {#sec-encabezados}

Los archivos de encabezados incluyen definición de macros y declaración de funciones, tipos, y variables. Son insertados en los archivos fuente mediante directivas `#include` (ver @sec-include). Su principal función es evitar la duplicación de código, ya que contienen declaraciones, definiciones de tipos y definiciones de constantes que son comunes a varios archivos fuente. Un encabezado puede a su vez incluir otros encabezados, y si se incluye varias veces un encabezado solo debiera insertarse la primera vez, siendo omitido mediante compilación condicional (ver @sec-compilacion-condicional) las veces siguientes. Las funciones y variables declaradas en un encabezado están definidas en otros archivos fuente o son parte de librerías. El @lst-ejemplo-encabezado presenta un encabezado sencillo. Observar que tiene un mecanismo de compilación condicional para evitar ser inserto múltiples veces. Este encabezado incluye otros encabezados necesarios para sus propias declaraciones y declara cinco funciones.

:::{.callout appearance="minimal"}
::::{#lst-ejemplo-encabezado lst-cap="sp_tiempo.h"}
```{.c}
#ifndef SP_TIEMPO_H
#define SP_TIEMPO_H
#include <stdint.h>   // define el tipo uint32_t
#include <stdbool.h>  // define el tipo bool
#include <i_accion.h> // define el tipo IAccion

void SysTick_Handler(void);
void SP_Tiempo_delay(uint32_t tiempo);
bool SP_Tiempo_addTimeout(uint32_t tiempo,IAccion * accion);
void SP_Tiempo_init(void);
uint32_t SP_Tiempo_getMilisegundos(void);
#endif
```
::::
:::

### Archivos fuente

Definen las funciones que contienen el código del programa, variables estáticas globales (de enlace externo) y variables estáticas de enlace interno (visibles solo dentro del archivo donde se declaran).

:::{.callout appearance="minimal"}
::::{#lst-archivo-fuente-1 lst-cap="espera.c"}
```{.c}
#include <stdbool.h>   // bool
#include <stdint.h>    // uint32_t
#include <stm32f1xx.h>   // SysTick_Config, SystemCoreClock, __WFE
#include "espera.h"    // este módulo
static bool inicializado = 0;
static volatile uint32_t ticks;
static void inicializa(void){
  SysTick_Config(SystemCoreClock/1000);
  inicializado = 1;
}
void SysTick_Handler(void){
  ++ticks;
}
void espera(uint32_t ms){
  if (!inicializado) inicializa();
  const actual = ticks;
  while ((ticks - actual) < ms) __WFE();
}
```
::::
:::

### Función main

El punto donde inicia la ejecución de nuestro programa se denomina punto de entrada. En C el punto de entrada de nuestro programa es una función llamada main que *debe retrornar un valor entero*. Si esta función retorna el programa termina. En el software embebido esta función tendrá un lazo infinito, no retornará nunca.

:::{.callout appearance="simple"}
::::{#lst-aplicacion-parpadeo lst-cap="miapp.c"}
``` c
#include <stdbool.h> // bool
#include "pin.h"   // Pin_salida, Pin_escribe
#include "espera.h"  // espera
#include "miapp.h"   // este módulo
int main(void)
{
  bool estado=0;
  Pin_salida(PUERTO_LED,PIN_LED);
  while(1){
    Pin_escribe(PUERTO_LED,PIN_LED,estado);
    espera(500);
    estado = !estado;
  }
  return 0;
}
```
::::
:::

### Sentencias

Son uno de los componentes, junto con las declaraciones, de todo programa en lenguaje C. Existen varias clases.

-   **Sentencias compuestas:** (llamadas **bloques de código** o **bloques**). Son secuencias de cero o más declaraciones y sentencias encerradas entre corchetes `{ }`.
-   **Sentencias de expresión:** Consisten en una expresíon seguida de un punto y coma `;`. La mayor parte de las sentencias en C son sentencias de expresión. Un punto y coma solo, sin expresión, es una sentencia nula.
-   **Sentencias de selección:** Permiten ejecutar distintas sentencias en forma condicional. `if`, `if-else`, `switch`
-   **Sentencias de iteración:** Permiten ejecutar repetidamente una sentencia. `while`, `do-while`,`for`
-   **Sentencias de salto:** Permiten cambiar el flujo de ejecución en forma incondicional `return`, `break`, `continue`, `goto`

:::{.callout appearance="simple"}
::::{#lst-sentencias-if lst-cap="Programa con sentencias if"}
```{.c}
#include <stdio.h>
int main(void)
{ // bloque
  int N,D,Q,R; // declaración (no es una sentencia)
  puts("Ingrese numerador: "); // sentencia de expresión
  scanf("%d",&N);
  puts("Ingrese denominador: ");
  scanf("%d",&D);
  /*  Condición. Es un expresión. Si su valor es verdadero
    se ejecuta el bloque if, sinó el bloque else.
    ↓                          */
  if (D==0) {
    puts("División por cero!\n"); // D==0 es verdadero
  }
  else { // D==0 es falso (D distinto de cero)
    Q = N/D; // asignación, cociente
    R = N%D; // asignación, módulo
    printf("Cociente %d, Resto %d",Q,R); // llamado a función
  }
  return 0; //Sentencia de salto, retorna con valor 0.
}
```
::::
:::

:::{.callout appearance="minimal"}
::::{#lst-sentencia-switch lst-cap="programa con sentencia switch"}
```{.c}
typedef enum {X_NULO,X_ENCENDER,X_APAGAR,X_CONMUTAR} Evento;
typedef enum {E_APAGADO, E_ENCENDIDO} Estado;
Estado transicion(Estado const estado,Evento const evento){
  Estado nuevo;
  /*     Expresión que debe producir un valor entero.
       Se evalúa solo una vez. Luego salta a la etiqueta
       case cuyo valor coincide con el resultado o a la
       etiqueta default si ninguno coincide.
        │
        ↓                        */
  switch(estado){
  case E_APAGADO:
    // Sentencia switch anidada
    switch(evento){
    // Las etiquetas valen solo en el bloque
    // donde están definidas. Si no hay una
    // sentencia break la ejecución continúa
    // en las etiquetas siguientes.
    case X_ENCENDER: // estas dos etiquetas corresponden a la misma sentencia.
    /*fallthru*/case X_CONMUTAR: // Una sentencia puede tener varias etiquetas.
      nuevo = E_ENCENDIDO;
    break; // Sale del switch. SI SE OMITE CONTINÚA EN EL SIGUIENTE case
    // usar el comentario /*fallthru*/ para indicar que la ausencia de
    // break NO ES ACCIDENTAL
    case X_APAGAR:
    /*fallthru*/default:
      nuevo = estado;
    }
  break;
  case E_ENCENDIDO:
    switch(evento){
    case X_APAGAR:
    /*fallthru*/case X_CONMUTAR:
      nuevo = E_APAGADO;
    break; default:
      nuevo = estado;
    }
  break;
  default:
    nuevo = E_APAGADO;
  }
  return nuevo;
}
```
::::
:::

::: callout
Switch evalúa la expresión de selección una sola vez, luego salta según su valor. En esos casos es más claro que sentencias `if-else` anidadas. No olvidar el `break` al final de cada `case`.
:::

:::{.callout appearance="minimal"}
::::{#lst-sentencia-for lst-cap="La sentencia for"}
```{.c}
int producto_punto(int n, int const *v1,int const *v2){
  int a = 0;
/*  Inicialización. Opcional. Permite declarar variables.
          │
          │    Condición evaluada antes de cada ejecución
          │    del bloque. Si su resultado es verdadero el
          │    bloque es ejecutado. Opcional. Si se omite
          │    genera un lazo infinito.
          │     │
          │     │  Expresión de incremento, ejecutada 
          │     │  luego de cada ejecución del bloque y
          │     │  antes de comprobar la condición para la
          │     │  siguiente ejecución. Opcional.
          ↓     ↓   ↓                   */
  for(int k=0;k<n;++k){ // bloque
    a += v1[k]*v2[k];
  }
  return a;
}
```
::::
:::

::: callout-tip
La sentencia `for (;;) {...}` produce un lazo infinito.
:::

![Lazo `for` destacado en rojo.](producto_punto.png)

:::{.callout appearance="minimal"}
::::{#lst-encabezad-rcuad lst-cap="rcuad.h"}
``` c
#ifndef RCUAD_H
#define RCUAD_H
#include <stdbool.h> // bool, true, false
typedef struct Opt_float{
  bool es_float;
  float valor;
} Opt_float;
Opt_float raiz_cuadrada(float num);
#endif
```
::::
:::

:::{.callout appearance="minimal"}
::::{#lst-sentencia-while lst-cap="rcuad.c - Ejemplo de sentencia *while*"}
``` c
// Ejemplo iteración while
#include "rcuad.h"
static float error_abs(float ref,float val){
  float const err = ref - val;
  if (err<0) return -err;
  return err;
}
Opt_float raiz_cuadrada(float num){
  float tol = num*1e-6, r = 1,err;
  if (num < 0) return  (Opt_float){false};
  if (num == 0) return (Opt_float){true,0};
  while(error_abs(num,r*r) > tol){
    r = (num/r+r)/2;
  }
  return (Opt_float){true,r};
}
```
::::
:::

:::{.callout appearance="minimal"}
::::{#lst-sentencia-dowhile lst-cap="Ejemplo de sentencia *do..while*"}
```{.c}
// Ejemplo de do-while
#include <stdio.h>
#include "rcuad.h"
int main(void){
  Opt_float r;
  do{
    float x;
    printf("Ingrese un número no negativo o -1 para terminar: ");
    scanf("%f",&x);
    r=raiz_cuadrada(x);
    if (r.es_float)
      printf("La raíz cuadrada de %g es %g.\n",x,r.valor);
  }while(r.es_float);
  return 0;
}
```
::::
:::

::: callout-tip
`do-while` ejecuta el bloque de código **al menos una vez**, mientras que `while` solo lo ejecuta si se cumple la condición.
:::

## Declaraciónes

Una declaración indica la existencia de una variable o función, define su tipo, modo de acceso y (en el caso de variables) puede definir su valor inicial. La declaración de una variable realiza la correspondiente reserva de memoria.

:::{.callout appearance="minimal"}
::::{#lst-declaraciones lst-cap="Ejemplos de declaraciones"}
```{.c}
  static const signed int mivar_1 = 10;
/*────── ───── ────────── ─────── ────
 *   ↑     ↑        ↑        ↑      ↑
 *   │     │        │        │      └── Inicializador
 *   │     │        │        └ Declarador de variable
 *   │     │        └──────── Especificadores de tipo
 *   │     └───────────────────── Calificador de tipo
 *   └────── Especificador de clase de almacenamiento
 */

  int A, B = 5, *C = &B;
/*─── ─  ─ ───  ── ────
 * ↑  ↑  ↑  ↑    ↑   ↑
 * │  │  │  │    │   └──── Inicializador ⎫ Lista
 * │  │  │  │    └ Declarador de puntero ⎪ de
 * │  │  │  └───────────── Inicializador ⎬ declaradores
 * │  │  └─────── Declarador de variable ⎪ e
 * │  └────────── Declarador de variable ⎭ inicializadores
 * └───────────────────────────────── Especificador de tipo 
 *
 * Una declaración fuera de una función tiene
 * por defecto la clase de almacenamiento
 * extern
 */

  void funcion1(int a,int b);
/*──── ────────┴────────────
 * ↑      ↑          ↑                    ⎫
 * │      │          └ Lista de parámetros⎬ Declarador de
 * │      └───────────────── Identificador⎭ función
 * └───────────────────── Especificador de tipo retornado
 */

  void *funcion2(int a,int b);
/*──── ─┴───────┴────────────
 * ↑   ↑  ↑          ↑
 * │   │  │          └ Lista de parámetros⎫ Declarador de
 * │   │  └───────────────── Identificador⎬ función que
 * │   └────────── Retorna puntero a tipo ⎭ retorna puntero
 * └─────────────── Especificador de tipo
 */
```
::::
:::

## Memoria de datos

Un microcontrolador posee al menos memoria de programa no volátil (usualmente flash) y memoria de datos volátil (usualmente sram). La memoria de programa contiene al programa y las constantes. La memoria de datos contiene las variables. Nota: Para usar una variable en un cómputo (parte de) su valor debe copiarse a los registros del procesador.

## Organización de memoria de datos

![](org_mem_datos.png){fig-align="center"}

## Clases de almacenamiento

En C las variables pueden tener distintas clases de almacenamiento según la forma en que se reserva memoria para las mismas. Las clases de almacenamiento más relevantes son estático y automático.

*Almacenamiento estático* : La memoria es reservada en tiempo de compilación (antes de ejecutar el programa) en las secciones .data (inicializadas a algún valor) y .bss (inicializadas a cero).

-   Variables declaradas fuera de una función
-   Variables dentro de una función con especificador `static`

*Almacenamiento automático* : La memoria es reservada en la pila de llamados al activarse una función y liberada al retornar.

-   Variables declaradas dentro de una función sin especificador o con especificador `auto` (en desuso, al igual que `register`)

-   Los parámetros de una función son variables con esta clase de almacenamiento

*Almacenamiento en registro* : En lo posible la variable se mantendrá en un registro del procesador. No puede obtenerse su dirección (se supone que no está en memoria).

-   Variables declaradas dentro de una función con especificador `register`

::: callout-warning
Esta clase **es obsoleta**. El compilador hace la optimización en forma automática cuando es oportuno con una variable auto. **No usar**.
:::

## Definición de tipo

La definición de tipo es considerada una clase de almacenamiento, pero no reserva memoria para una variable sino que convierte el identificador en un nombre abreviado para el tipo de datos especificado. Se indica con `typedef`

:::{.callout appearance="minimal"}
::::{#lst-typedef lst-cap="Ejemplo de definición de tipo"}
```{.c}
// Define el tipo dword como sinónimo
// de long long int
typedef long long int dword;
```
::::
:::

## Vinculación o enlace

Las variables son símbolos asociados a espacios de memoria que almacenan datos. La vinculación o enlace determina el ámbito desde el es accesibles una variable declarada fuera de una función.

**Sín vinculación** : variables declaradas dentro de una función (estáticas o automáticas) y parámetros, solo pueden ser accedidas dentro del bloque de código donde fueron declaradas.

:::{.callout appearance="minimal"}
::::{#lst-sin-vinculacion lst-cap="Variables sin vinculación"}
``` c
// a, b y c son variables 
// con almacenamiento automático
// y sin vinculación
int suma(int a,int b){
  int c = a+b;
  return c;
}
// numeros es una variable
// con almacenamiento estático
// y sin vinculación
int main(void){
  static int numeros[500];
  ...
}
```
::::
:::

**Vinculación interna** : variables `static` declaradas fuera de una función. Solo son accesibles desde el código de la unidad de traducción (archivo .c y encabezados incluidos) donde fueron declaradas, a partir del primer punto en que fueron declaradas.

:::{.callout appearance="minimal"}
::::{#lst-vinculacion-interna lst-cap="Declaración de variable con vinculación interna"}
```{.c}
static int mivar1;
```
::::
:::

**Vinculación externa** : variables `extern` (o sin especificador) declaradas dentro (no recomendable) o fuera de una función. Son accesibles desde cualquier unidad de traducción (archivo .c) y desde el código externo si se trata de una librería.

:::{.callout appearance="minimal"}
::::{#lst-vinculacion-externa lst-cap="Declaración de variables con vinculación externa"}

**ejemplo.h**

```{.c}
#ifndef EJEMPLO_H
#define EJEMPLO_H
// Esta es una declaración externa que no reserva espacio
extern int numero_global;
#endif
```

**ejemplo.c**

```{.c}
#include <ejemplo.h>
// Si se omite extern la declaración también es externa 
// pero sí reserva espacio. Solo puede hacerse reserva 
// de espacio en un archivo .c, en los demás archivos
// que acceden la variable debe usarse extern
// (normalmente se hace al incluir ejemplo.h)
int numero_global;
```
::::
:::

## Calificadores

Indican al compilador como se debe utilizar una variable. Los calificadores son `const`, `volatile` y `restrict`.

::: callout-note
Desde C11 existe el calificador \_Atomic, que garantiza que las operaciones de incremento (`++`), decremento (`--`) y asignación compuesta (`+=`, `-=`, `|=`, `&=`, etc.) se *ejecutan sin interrupción* en casos donde varios procesos pueden acceder concurrentemente a memoria. Todo esto implica también que los accesos se suponen con efecto secundario, de la misma forma que *volatile*.
:::

**Calificador const** : Indica que la variable es de solo lectura. Debe asignarsele un valor al declararla (excepto variables extern, que solo en una de sus declaraciones puede tener asignado un valor). Si califica el tipo apuntado por un puntero indica que ese puntero puede ser usado solo para leer pero no para modificar memoria.

:::{.callout appearance="minimal"}
::::{#lst-calificador-const lst-cap="Ejemplo de uso del calificador *const*"}
```{.c}
int suma(int a,int b){
  const int c = a + b;
  return c; 
}
int strlen(const char *c){
  int A=0;
  while(*c){ // lee
    ++A;
    ++c; // desplaza puntero
  }
  return A;
}
```
::::
:::

**Calificador volatile** : Inidica que el contenido de la variable puede tener un efecto secundario sobre el hardware o bien ser afectado por el hardware en forma independiente al flujo normal del programa. Debe ser usado si una variable es accedida desde una rutina de servicio de interrupción.

:::{.callout appearance="minimal"}
::::{#lst-calificador-volatile lst-cap="Ejemplo de uso de calificador *volatile*"}
```{.c}
volatile unsigned long ticks;
// Rutina de servicio de interrupción llamada
// por el timer SysTick una ves por milisegundo
void SysTick_Handler(void){
  ++ticks;
}

void espera(unsigned long ms){
  const unsigned long inicial = ticks;
  while(ticks - inicial < ms)
    __WFE();
}
```
::::
:::

## Tipos de datos

En C cada *variable* tiene asociado un tipo de dato, que determina la cantidad de memoria que requiere y la interpretación hace el compilador sobre el contenido de esa memoria. C tiene tipos básicos y derivados.

Los **tipos básicos** en C son `void`, *tipos aritméticos*, *tipos definidos por el usuario* con `typedef`, *estructuras*, *uniones* y *enumeraciones*.

Los tipos derivados son arreglos, funciones, punteros y (desde C11) tipos atómicos.

`void` : El tipo void es un tipo especial que indica que no hay un valor.

-   No puede declararse una variable `void`.
-   Si una función indica como tipo retornado `void` significa que no retorna ningún valor.
-   Si la lista de parámetros de una función es `(void)` indica que la función no toma ningún parámetro.
-   Un puntero a `void` es un puntero universal, debe convertirse a otro tipo de puntero para usarse y puede asignársele la dirección de cualquier puntero excepto un puntero a función.

:::{.callout appearance="minimal"}
::::{#lst-tipo-void lst-cap="El tipo *void*"}
``` c

/* Una rutina de servicio de interrupción
 * es llamada por hardware. No puede recibir
 * parámetros ni retornar valor (pues no hay
 * quien lo reciba).
 */ 
   void SysTick_Handler(void){...}
/*   ↑          ↑
 *   │          └ No acepta argumentos
 *   └───────────────────────── No retorna valor
 */

/* Función de librería estándar que reserva
 * memoria en forma dinámica en el Heap.
 * Retorna un puntero sin tipo, que indica
 * una dirección de memoria sobre cuyo contenido
 * no se tiene ninguna información.
 */
  void * malloc(size_t size);
```
::::
:::

*Tipos aritméticos* : indican que una variable contiene un valor numérico.

:::{.callout appearance="minimal"}
::::{#lst-tipos-aritmeticos lst-cap="Tipos aritméticos"}
```{.c}
// Tipo lógico. Solo toma valores 0 (falso) y 1(verdadero). En ARM 8 bits
_Bool flag=1;
// Tipos de caracter. Enteros de al menos 8 bits. En ARM 8 bits
char caracter='A'; // usado para representar caracteres.
signed char x=123; // con signo
unsigned char y=0b11011001; // sin signo
// Enteros cortos, al menos 16 bits. En ARM 16 bits
signed short int A=23; // Sinónimos: signed short, short, short int
unsigned short int B=52300U; // sin signo. Sinónimo: unsigned short
// Enteros. Al menos 16 bits. En ARM 32 bits
signed int C=-19384; // Sinónimos: int, signed
unsigned int D=0x1234U; // sin signo. Sinónimo: unsigned
// Enteros largos. Al menos 32 bits. En ARM 32 bits
signed long int E=1293L; // Sinónimos: long int, signed long, long
unsigned long int F=998310LU; // sin signo. Sinónimo: unsigned long
// Enteros extendidos. Al menos 64 bits. En ARM 64 bits
signed long long int G=234102391304LL; // signed long long, long long
unsigned long long int H=0x0123456789ABCDEFLLU; // unsigned long long
```
::::
:::

::: callout-tip
El compilador de C acepta las siguientes constantes numéricas enteras:

-   **Binario:** indicado con el prefijo `0b`. Ej. `0b111010011`\
-   **Octal (base 8):** indicado anteponiendo un cero. Ej. `0723`.
-   **Decimal:** un número decimal *sin ceros a la izquierda*. Ej. `467`.
-   **Hexadecimal:** indicado con el prefijo `0x`. Ej. `0x1d3` o `0x1D3`.
:::

*Tipo de dato de los literales enteros*: Para indicar el tipo del entero se usan sufijos (caracteres incluidos luego de escribir el número), que pueden ubicarse en cualquier orden.

-   Sin sufijos es un tipo `int` (entero con signo de al menos 16 bit, en ARM 32 bit).
-   Sufijo `U` o `u` indica `unsigned` (entero sin signo).
-   Sufijo `L` o `l` indica `long` (al menos 32 bit). *Usar siempre `L` para evitar confusión con el número uno `1`.*
-   Sufijo `LL` o `ll` indica `long long` (al menos 64 bit). *Usar siempre `LL` para evitar confusión con el número uno `1`.*

:::{.callout appearance="minimal"}
::::{#lst-literales-enteros lst-cap="Literales enteros"}
```{.c}
int A=0b111010011,B=0773,C=467,D=0x1d3,E=-1230;
unsigned u=0x1123U;
long x=1922L, y=0655733L, z=-1923L;
unsigned long  v=0x12345678LU;
long long w=-80123456789LL;
unsigned long long m=0xDEADBEEFDEADBEEFuLL;
```
::::
:::

*Punto flotante*: Los tipos `float` y `double` representan números en punto flotante binarios. La representación en punto flotante es análoga a la representación científica decimal, puede escribirse como $\pm{m}\cdot2^{E}$. Consta un signo (positivo o negativo), una mantisa $m$ con $0 < m < 2$ y un exponente $E$.

:::{.callout-note}
Al operar con tipos enteros y de punto flotante, el valor entero se convertirá a punto flotante antes de operar. Al operar con tipos de punto flotante de distinta capacidad, el valor del tipo de menor capacidad se convertirá al tipo de mayor capacidad antes de operar.
:::

:::{.callout appearance="minimal"}
::::{#lst-literales-punto-flotante lst-cap="Literales de punto flotante"}
``` c
// El soporte por hardware está en la unidad de punto flotante (FPU), no en el CPU
// Cortex-M3 no inclue FPU, Cortex-M4 Sí
// Si no hay FPU se emula por software, computacionalmente costoso
float a = 1.45e-45; // Punto flotante de 32 bit
double b = 1.4535e-500; // Punto flotante de 64 bit
long double c = 1.234204221;
```
::::
:::

::: callout-important
Si es necesario usar punto flotante y se requiere procesamiento rápido y/o bajo consumo, uno de los requerimientos a la hora de elegir un microcontrolador es que cuente con unidad de punto flotante (FPU).

Si el rendimiento no es importante muchas veces es suficiente con el punto flotante emulado.
:::

## Conversión implícita y promoción de tipos enteros {#sec-promocion-enteros}

Cuando se realizan operaciones aritméticas unarias (+,-,~), binarias (+,-,*,/,%), relacionales (&lt;,&lt;=,==,&gt;=,&gt;) y lógicas bit a bit (&,^,|) o se usa el operador condicional (?:). Se realizará una conversión de tipo antes de operar, de la siguiente manera:

1. Si todos los valores del tipo son representables por un `int` es convertido a `int`
2. Si no es representable por `int` pero es representable por `unsigned int` es convertido en `unsigned int`
3. Si el tipo excede los rangos de `int` y `unsigned int` permanece inalterado

Luego de esta conversión, en el caso de las operaciones binarias y el operador condicional si los tipos de los operandos son distintos se realiza la conversión:

1. Si los tipos son ambos con signo o ambos sin signo, el tipo con el menor rango de valores posibles es convertido al otro tipo
2. Si uno de los tipos es sin signo y el otro con signo. 
  1. Si el tipo con signo puede acomodar todos los valores del tipo sin signo, el operando del tipo sin signo es convertido al otro tipo.
  2. Si el tipo sin signo tiene igual o mayor cantidad de valores que el tipo con signo entonces el operando con signo es convertido al otro tipo
  3. Si el tipo sin signo tiene menor cantidad de valores que el tipo con signo, pero el tipo con signo no puede representar todos sus valores, entonces ambos serán convertidos a la version sin signo correspondiente al tipo con signo.

Al convertir un tipo con signo en uno sin signo simplemente se reinterpretan los valores. El @lst-promocion-enteros tiene algunos ejemplos. Los últimos dos muestran las particularidades de estas reglas que muchas veces no son intuitivas.

:::{.callout appearance="minimal"}
::::{#lst-promocion-enteros lst-cap="Promoción de tipos enteros"}
```{.c}
#include <stdio.h>
int main()
{
  unsigned char a = 4;
  signed char b = -3;
  unsigned short c = 33;
  unsigned int f = 2;
  unsigned long long q = 1;
  long long int aux;

  // escribe 1
  // a y b son convertidos a int, luego se realiza la suma
  // (el resultado final es convertido luego a long long int)
  aux = a+b;
  printf("%lld\n",aux);

  // escribe 30
  // b y c son convertidos a int, luego se realiza la suma
  aux = b+c;
  printf("%lld\n",aux);

  // escribe 4294967295
  // b es convertido a int, luego a unsigned int porque el otro
  // operando de la suma es unsigned int. Finalmente se realiza la suma.
  aux = b + f;
  printf("%lld\n",aux);

  // escribe "q + b > 0"
  // b es convertido a int, luego a unsigned long long por ser el otro operando
  // de ese tipo (sin signo y de mayor capacidad que int). Luego se suma el
  // resultado, (2^64-3 + 1). Este valor será mucho mayor que cero. Antes de
  // comparar el cero se convierte al tipo unsigned long long.
  if (q + b > 0){
    printf("q + b > 0\n");
  }else{
    printf("q + b < 0\n");
  }
  return 0;
}
```
::::
:::

:::{.callout-tip}
Para evitar problemas, no mezclar tipos con signo y tipos sin signo. Para uso general preferir los tipos con signo.
:::

## Enumeraciónes

Las enumeraciones son tipos que pueden tomar un valor entre un conjunto discreto de valores asociados a nombres. Los nombres operan como constantes enteras válidas en el ámbito donde es visible el tipo. El tamaño en memoria de una variable de tipo `enum` depende de la implementación y debe ser suficiente para almacenar el valor de todas las constantes definidas en una enumeración dada. Los valores de las constantes de una enumeración son de tipo entero (`int`) y pueden usarse en cualquier sitio donde pueda utilizarse un valor entero. Usualmente un tipo `enum` sin valores negativos resulta en un tipo subyacente entero sin signo.

:::{.callout appearance="minimal"}
::::{#lst-ejemplo-enum lst-cap="Ejemplo de enumeración"}
```{.c}
// Si no se dan valores explícitamente
// el primer elemento será cero y subsiguientes
// elementos toman el valor siguiente del elemento
// anterior
typedef enum {
  FUERA_DE_SERVICIO,  // FUERA_DE_SERVICIO vale 0
  VERDE = 10,     // VERDE vale 10
  AMARILLO,       // AMARILLO vale 11
  ROJO,         // ROJO vale 12
}EstadoSemaforo;
```
::::
:::

::: callout-important
Los valores de las constantes de una enumeración son limitados a los valores del tipo de datos `int`, que dependiendo de la plataforma puede ser 16, 32 o 64 bit. En la plataforma ARM de 32 bit el tipo entero es de 32 bit.
:::

::: callout-tip
Al definir una enumeración se crean constantes enteras para sus valores. Estas constantes son símbolos del compilador, no macros. Valen solo en el ámbito dentro del cual se definió la enumeración y pueden incorporarse en la información de depuración.
:::

## Estructuras {#sec-estructuras}

Un tipo estructura es una concatenacion de uno o mas tipos de datos. Son **conjunciones** de tipos, es decir

`struct{int a,char b,int c} mivar;`

reserva memoria para a **y** b **y** c. Además reservará memoria para mantener la alineación de modo que c comienze en dirección múltiplo de 4 (porque su tamaño es de 32 bit).

El acceso a los miembros de una estructura a partir de un objeto (llamado *lvalor*) tipo estructura se realiza mediante el operador punto (`mivar.a` para acceder al miembro `a` del objeto estructura en la variable `mivar`). Para acceder a un miembro de una estructura a través de un puntero a la misma ([ver @sec-punteros])

:::{.callout appearance="minimal"}
::::{#lst-ejemplo-struct lst-cap="Ejemplo de declaración de tipo *struct*"}
```{.c}
/*  ┌──── Palabra clave, indica que es un tipo estructura
    │     ┌ Etiqueta que se refiere a esta definición
    │     │         ┌──── Definición de struct Estructura
    ↓     ↓         ↓     */
  struct Estructura {
    int miembro_1;
    // Definición de estructura anónima (sin etiqueta)  
    struct {
      long parte_1;
      long parte_2;
    }miembro_2;
    // Los miembros pueden ser arreglos
    char miembro_3[20];
    // Los miembros pueden ser punteros
    unsigned long *miembro_4;
  } var1, *var2;
/*   ↑      ↑
     │      └─ Declarador de puntero a estructura
     └──────── Declarador de variable estructura
*/


// Define un tipo Estructura
typedef struct Estructura Estructura;
// Tipo Estructura
Estructura var3;
// Equivalente
struct Estructura var4;
 int main(void){
  var2 = &var1;
  // Acceso a miembros de estructura
  var1.miembro_1 = 5;
  var1.miembro_2.parte_1 = 4;
  // Acceso a miembros desde puntero a estructura
  var2->miembro_2.parte_2 = 3;
  var2->miembro_3[5]=4;
  // Forma equivalente (pero no usada). LOS PARÉNTESIS SON NECESARIOS
  (*var2).miembro_3[6]=5;
  return 0;
 }
```
::::

::::{#lst-ejemplo-struct-por-valor lst-cap="Estructuras: pasaje por valor e inicializadores"}
```{.c}
typedef struct Punto{
  int x,y;
} Punto;
Punto Punto_suma(Punto a,Punto b){
  // a y b son copias (pasaje por valor)
  // Literal compuesto de tipo estructura
  return (Punto){.x = a.x + b.x,
           .y = a.y + b.y};
}
int main(void){
  // inicialización
  Punto a={1,4},c={0}; // con lista
  Punto b={.y=7};    // con designación
  // Miembros omitidos son inicializados a 0
  c = Punto_suma(a,b); // no altera a y b
  return 0;
}
```
::::

::::{#lst-ejemplo-struct-por-ref lst-cap="Estructuras: pasaje por referencia"}
```{.c}
typedef struct MiEstado{
  uint32_t R[16], xpsr;
} MiEstado; // Ocupa 68 bytes
void muestraEstado_copia(MiEstado e){
  // Cada vez que se llama a esta función
  // se copian los 68 bytes!
  ...
}
void muestraEstado_ptr(MiEstado *e){
  // Esta función tiene acceso de escritura
  // al estado, es INSEGURO!
  ...
}
void muestraEstado_cptr(const MiEstado *e){
  // Es la mejor manera. Omite copiar el estado
  // pero lo proteje contra cambios imprevistos
  ...
}
```
::::
:::

## Uniones

Un tipo union es un tipo que puede contener valores de otros tipos, pero solo un valor por vez. Son **disyunciones** de tipos, es decir

`union {int a,char b,long long c} mivar;`

reserva memoria para el más grande entre a,b y c. Puede contener a **o** b **o** c, pero **solo uno por vez**. Al usar uniones lo mejor es ubicarlas dentro de estructuras donde otro miembro determine *cual de los valores es contenido*.

``` c
typedef struct Var{
  enum {ERROR,NUM_16,NUM_32,NUM_64} tipo;
  // Si no se indica miembro, los miembros de la
  // union se acceden como si fuesen miembros de
  // la estructura
  union{
    enum CodigoError error;
    int16_t v16;
    int32_t v32;
    int64_t v64;
  };
} Var;
```

``` c
Var recibe_elemento(void){
  Var r;
  recibe_bytes(sizeof(r.tipo),&r.tipo);
  switch(r.tipo){
  case ERROR:
    recibe_bytes(sizeof(r.error),&r.error);
  break;case NUM_16:
    recibe_bytes(2,&r.v16);
  break;case NUM_32:
    recibe_bytes(4,&r.v32);
  break;case NUM_64:
    recibe_bytes(8,&r.v64);
  break;default:
    r.tipo = ERROR;
    r.error = MENSAJE_NO_VALIDO;
  }
  return r;
}
```

## Tipo función

Las funciones son los objetos que contienen el código ejecutable del programa. Su tipo define la interfaz entre el código que contienen y el resto del programa. Cuando se declara una función esto no reserva memoria alguna, sino que indica al compilador que existe una definición de función con el mismo nombre que contiene código ejecutable, e indica como interactuar con ese código.

::: callout-note
En el caso de las funciones inline (para las cuales el compilador puede insertar el código de la función en lugar de hacer un llamado a subrutina), la definición toma el lugar de la declaración y hay una declaración en el punto donde sería la definición.
:::

## Declaración de funciones

El tipo función es una clase de tipo derivado, donde el tipo base identifica el tipo retornado por la función, y además se especifican otros tipos que corresponden a los argumentos de la función. Un declarador de función se construye ubicando una lista de argumentos entre paréntesis a la derecha del identificador. Si una función no retorna valor su tipo base debe ser *void*. Y si no acepta argumentos la lista de argumentos debe contener solo uno, de tipo *void*.

::: callout-note
En este curso trataremos la declaración de funciones moderna, correspondiente a C99 y posterior. La forma histórica sigue siendo soportada pero no es recomendable.
:::

``` c
  int f1(void), f2(int,int);
/*─── ────────  ─────────── 
 * ↑  ↑     ↑
 * │  │     └ Declarador de función que
 * │  │       acepta dos argumentos enteros
 * │  │       y retorna un valor entero
 * │  │
 * │  └──── Declarador de función que no acepta
 * │    argumentos y retorna un valor entero
 * │
 * └───── Tipo base entero, determina el tipo de
 *    valor retornado.
 */
```

::: callout-note
Si bien este ejemplo declara dos funciones en con el mismo especificador de tipo base, es conveniente por claridad declarar cada función por separado.
:::

``` c
typedef struct Opc_ResultadoDiv{
  bool es_resultado;
  int cociente;
  int resto;
} Opc_ResultadoDiv;

Opc_ResultadoDiv dividir(int numerador,int denominador);
/*
 * Declaración de una función dividir que  acepta dos
 * argumentos enteros y retorna un valor tipo estructura
 * El nombre dado a los argumentos es opcional, pero
 * recomendable por claridad
 */
```

::: callout-note
El tipo `Opc_ResultadoDiv` comienza su nombre por Opc\_ por *opcional*. En caso de que `es_resultado` sea *falso* significa que ocurrió un problema (divisor cero) y no fue posible determinar el resultado. Este clase de tipo de estructura Op\_... es práctico en casos donde puedan ocurrir errores.
:::

Si el tipo de una declaración de función tiene el especificador *static*, se está declarando una función visible solo dentro de la unidad de traducción (archivo .c y encabezados) actual. En ese caso la función debe ser definida en la misma unidad de traducción donde fue declarada.

``` c
static int func1(int a,char b);
int main(void){
  return func1(1,3);
}
static int func1(int a,int b){
  return (b-a)*(b+a);
}
```

::: callout-caution
Es un error si termina el archivo sin definir func1.
:::

## Funciones inline

En C99 se introdujo un especificador `inline` que indica que el código de la función puede ser "pegado" dentro de otra función en lugar de hacer un llamado. Esto permite evitar la sobrecarga de llamar a una función sencilla.

::: callout-tip
El compilador de C solo hace la inclusión en línea del código **si está activada la optimización**. Si no está activada la optimización el compilador realizará un llamado normal en su lugar.
:::

::: callout-important
Las funciones `inline` invierten las posiciones de la declaración y la implementación. Son implementadas en el encabezado y declaradas en un archivo .c. En el archivo donde son declaradas se genera el código accesible de forma normal (cuando no es insertada en línea).

-   Donde originalmente iría la declaración va la implementación calificada por `inline`.
-   Donde originalmente iría la implementación va un declaración calificada por `extern inline`. Esta declaración es especial, indica que en este punto debe compilarse la función de manera normal. Esto es necesario para el uso normal de la función, si se omitiera fallaría el linker si se compila sin optimizar o se llama la función desde un puntero.
:::

``` c
#ifndef EJEMPLO_H
#define EJEMPLO_H

int fn_normal(int a,int b);

inline int fn_inline(int a,int b)
{
  return a-b;
}
#endif
```

``` c
#include "ejemplo.h" // Este módulo

int fn_normal(int a,int b){
  return a*b;
}

// En este caso extern es necesario.
extern inline int fn_inline(int a,int b);
```

## Llamado a función

Para hacer uso de una función se emplea una expresión de llamado a función. Dicha expresión consiste en el identificador (nombre) seguido de la lista de parámetros entre paréntesis, en este caso los paréntesis son el operador "llamado a función". En caso de que la función no acepte parámetros debe usarse una lista vacía "`()`". En una expresión el nombre de la función es evaluado a un puntero a función del tipo correspondiente a su declaración. El operador llamado a función opera sobre dicho puntero para efectuar el llamado.

``` c
#include <stdio.h>  // puts, fputs, stderr, EOF
#include <stdlib.h> // exit

// a(b,c,d) : operador llamado a función con operandos a, b, c y d. El operando a
// es un puntero a función o un objeto función (dirección de memoria de destino)
// mientras que b, c y d son los parámetros en el llamado (dependen del tipo
// de a)

static void decir_hola(void){
  // Llamado a puts, acepta un parámetro y retorna un valor entero
  const int resultado = puts("Hola Mundo!\n");
  if (resultado == EOF){
    // El valor retornado por fputs es ignorado.
    fputs("Error al escribir en STDOUT\n",stderr);
    exit(1);
  }
}
int main(void)
{
  // decir_hola no acepta parámetros ni retorna valor. Los paréntesis
  // vacíos indican que es un llamado a función y son necesarios.
  decir_hola();
}
```

## Arreglos

Un arreglo es un tipo de datos compuesto que contiene varias instancias del tipo de dato base dispuestas en forma contigua en memoria. El declarador de arreglo es indicado por un par de corchetes a la derecha del resto del declarador. Dentro de los corchetes se indica el número de elementos del arreglo. Un arreglo reserva memoria para todos sus elementos.

``` c
  int var1[5], var2[3][2];
  /*
   * El especificador de tipo base es entero (int)
   * var1 es un arreglo de 5 enteros
   * var2 es un arreglo de 3 arreglos de 2 enteros.
   *    Lo que puede considerarse un arreglo
   *    bidimensional de 3x2 enteros.
   */
```

Disposición en memoria arreglos en el ejemplo

![Nota: `&x` produce la dirección de `x` y `&x[1]` equivale a `&(x[1])`](memoria_arreglos.png)

## Limitaciones

-   No pueden declararse arreglos de funciones (pero sí de punteros a funciones).
-   Una función no puede retornar un tipo arreglo (aunque sí una estructura conteniendo un arreglo).
-   Se puede indicar un arreglo como parámetro de una función, pero en ese caso no se copiará el arreglo por valor sino que se pasará puntero al primer elemento del mismo.

## Indexado

Un objeto de tipo arreglo produce al evaluarse en una expresión un puntero a su primer elemento (una excepción es si se utiliza como argumento del operador sizeof, que retorna la cantida de memoria reservada por el tipo arreglo). El operador corchete '`[]`' permite acceder un elemento del arreglo según su índice. Se trata de un operador binario. En `a[b]` los argumentos son `a` (usualmente un puntero al primer elemento) y `b` (usualmente un índice entero). La expresión `a[b]` equivale a `*(a+b)` donde `*` es el operador "dirección de" y la suma usa las reglas de aritmética de puntero, por lo cual a la dirección dada por `a` se le suma el índice `b` multiplicado por el tamaño en bytes del tipo base del arreglo. Por ejemplo, si `a` tiene la dirección base `0x20000040` y el tipo base `int32_t`, entonces `a[20]` equivale a `*((int32_t *)0x2000090)`.

``` c
int  A[5]={1,2,3,4,5};

int primer_elemento_de_A(void){
  return A[0]; // Comienza de 0
}
int segundo_elemento_de_A(void){
  return A[1];
}
int * direccion_de_A(void){
  return A; // Sin corchete!
}
int * direccion_quinto_elemento_de_A(void){
  return &A[4];
}
```

:::{.callout-note}
En el operador indexado se pueden invertir los roles de puntero e índice (`a[b]` y `b[a]` tienen el mismo efecto), **sin embargo esto debe evitarse porque hace el código ilegible**. Esta nota tiene por finalidad poner sobre aviso al lector en caso que encuentre dicho uso en algún código fuente (usualmente constituirá intento de ofuscación de parte del autor de dicho código).
:::

## Arreglos como parámetros de funciones

Cuando un arreglo participa en una expresión es evaluado a un puntero a su primer elemento, esto ocurre también como parte de un llamado a función. Si uno de los argumentos en el llamado a función es especificado como un arreglo equivale a especificar un puntero al primer elemento.

``` c
// Las dos declaraciones son equivalentes
// Nota: Hay que especificar la longitud del arreglo en algún otro argumento, porque
// esa información se pierde. La función solo recibe un puntero al primer elemento
uint32_t suma(int n, int numeros[]);
// esta forma es equivalente
uint32_t suma(int n, int *numeros);

// Arreglos de longitud variable (VLA), solo como parámetros o variables automáticas.
void matmul(int n,int k,int m,
  int const A[n][k], int const B[k][m], int R[k][m]);
// Esta forma es equivalente
void matmul(int n, int k, int m,
  int const (*A)[k], int const (*B)[m], int (*R)[m])
{
  for (int fila=0;fila<n;++fila){
    for (int col=0;col<n;++col){
      R[fila][col] = 0;
      for (i=0;i<k;++i){
        R[fila][col] += A[fila][k]*B[k][col];
      }
    }
  }
}
```

::: callout-caution
Los punteros se pueden indexar como si fuesen arreglos, sin embargo **no son arreglos**.\
Si un puntero `P` apunta a un arreglo `A` entonces:

**Similitudes**

- `P` (valor del puntero) es igual a `A` (dirección del arreglo)
- `P[n]` es equivalente a `A[n]` (tanto para leer como modificar)
- `&P[n]` es igual a `&A[n]`

**Diferencias**

- `&P` es la dirección en memoria del puntero (`&P != A`).
- `&A` es la dirección en memoria del arreglo, que coincide con la direccion de su primer elemento (`(void*)&A == (void*)A`) aunque el tipo base de `&A` es *puntero a arreglo* en lugar a *puntero a elemento*.
- `sizeof P` (tamaño en memoria de P) siempre es el tamaño de un puntero.
- `sizeof A` (tamaño en memoria de A) es el espacio ocupado por A en memoria.
- `A` es la **dirección** del arreglo y por lo tanto no puede modificarse.
- `P` es el **valor** del puntero y sí puede modificarse.
:::

``` c
#include <stdio.h>  // puts
#include <assert.h> // assert
// assert(x) termina el programa con mensaje de error si x es falso
int main(void)
{
  int A[]={1,2,3,4,5,6,7,8,9,10,11,12};
  int *B = A;
  assert(A == B);
  for (int i=0;i<(sizeof A / sizeof A[0]);++i){
    assert(A[i] == B[i]);
    assert(&A[i] == &B[i]);
  }
  assert((void*)&A != (void*)&B);
  assert((void*)&B != (void*)B);
  assert((void*)&A == (void*)A);
  assert(sizeof A != sizeof B);
  puts("Todas las pruebas pasadas!\n");
  return 0;
}
```

::: callout-note
Puedes ejecutar una versión de este ejemplo [aquí](https://onlinegdb.com/FPG8GAUNY).
:::

## Punteros {#sec-punteros}

Un puntero es un tipo derivado cuyo valor es una dirección de memoria que, a su vez, contiene un objeto del tipo base. El tipo base puede ser cualquier otro tipo.

::: callout-caution
El tipo puntero se indica con un asterisco a la izquierda del identificador. Debido a la precedencia de operaciones, el asterisco se procesa *después* que los paréntesis y los corchetes que indican los tipos función y arreglo respectivamente. En estos casos deben usarse paréntesis para forzar que se evalúe primero el indicador de puntero.
:::

``` c
int x=5, *a=&x, **b=&a, ***c=&b;
/* x es una variable entero
 * a es una variable puntero a entero
 * b es una variable puntero a puntero a entero
 * c es una variable puntero a puntero a puntero a entero
 */
 int *x[4], (*y)[6];
 // x es un arreglo de cuatro punteros a entero.
 // y es un puntero a arreglo de cuatro enteros.
```

::: callout-tip
Notar en el ejemplo la diferencia entre x e y. La variable x almacena cuatro punteros a entero, mientras que y es un puntero a un arreglo de seis enteros.

`x[0]` es un puntero a entero.\
`y[0]` es un arreglo de 4 enteros.

La variable x contiene 4 punteros, por tanto su tamaño en memoria es el cuádruple de la variable y.
:::

## Interpretando declaraciones complejas {#sec-interpretacion-declaraciones}

Para interpretar una declaración compleja comenzar por el *identificador* (nombre de lo que se está declarando) considerar primero lo que hay a su derecha, luego lo que hay a su izquierda. Cada vez que se resuelva una declaración entre paréntesis considerar nuevamente derecha, luego izquierda.

Al evaluar cada parámetro de una decalración de función se procede de la misma manera.

::: callout

``` c
int const *A(int,int);
```

Identificador: `A` → *`A` es...*\
Derecha: `(int,int)` → *...una función con dos parámetros enteros...*\
Izquierda: `*` → *...que retorna un puntero a...*\
Izquierda: `int const` → *...entero con signo de solo lectura.*
:::

::: callout-tip
Los calificadores `const` y `volatile` pueden ir a izquierda o derecha de un tipo base.\
Pero **si califican un puntero deben ir siempre a la derecha del asterisco**.

Si siempre se ponen a la derecha de lo que califican es más dificil confundirse.
:::

::: callout
``` c
int const (*B(int,int))[9][3];
```
Identificador: `B` → *`B` es...*\
Derecha: `(int,int)` → *...una función con dos argumentos enteros...*\
Izquierda: `*` → *...que retorna un puntero a...*\
Fuera de los paréntesis:\
Derecha: `[9]` → *...un arreglo de nueve...*\
Continuando derecha `[3]` → *...arreglos de tres...*\
Izquierda: `int const` → *...enteros con signo de solo lectura.*
:::


::: callout
``` c
void (* const ivecs[16])(void) = {fn0,..,fn15};
```
Identificador: `ivecs` → *`ivecs` es...*\
Derecha: `[16]` → *...un arreglo de dieciseis...*\
Izquieda: `* const` → *...punteros constantes a...*\
Fuera de los paréntesis:\
Derecha: `(void)` → *...funciones que no aceptan argumentos...*\
Izquieda: `void` → *...y no retornan valor.*
:::

::: callout-important
Las variables de solo lectura (de tipo calificado por `const`) deben ser inicializadas en su definición (declaración que reserva la memoria).
:::

::: callout-tip
En "`int const *A;`" la variable `A` no es calificada por `const`, sino la posición de memoria a la que apunta. Por eso no hace falta inicializarla al definir.
:::

``` c
void (*const suma)(Vector const *self,const Vector *otro, Vector *resultado) = misuma;
```

::: callout
Identificador: `suma` → *`suma` es...*\
Izquierda: `*const` → *...un puntero constante a...*\
Fuera de los paréntesis:\
Derecha: `(Vector const *self,const Vector *otro, Vector *resultado)`\
→ *...función que acepta tres argumentos: dos punteros a constante tipo Vector (self y otro) y un puntero a tipo Vector (resultado); ...*\
Izquierda: `void` → *...y no retorna valor.*
:::

::: callout-important
Como `suma` es un tipo ***calificado constante***, debe ser inicializada al momento de su declaración.
:::

``` c
struct Pin_VT{
  void (*const modo_salida)(Pin *);
  void (*const modo_entrada)(Pin *);
  void (*const set_estado)(Pin *,bool);
  bool (*const get_estado)(Pin *);
  bool (*const get_entrada)(Pin *);
};
```

::: callout
No hay identificador → *No declara ningún objeto, ...*\
Izquierda: `struct Pin_VT{...}` → *...pero define una estructura de etiqueta `Pin_VT` cuyos miembros son: `modo_salida` y `modo_entrada`, dos punteros constantes a función que acepta un argumento puntero a `Pin` y no retorna valor; `set_estado`, un puntero constante a función que acepta un argumento puntero a `Pin`, un argumento tipo `bool` y no retorna valor; `get_estado` y `get_entrada`, dos punteros constantes a función que acepta un argumento puntero a `Pin` y retorna un valor tipo `bool`.*
:::

``` c
typedef enum {
  PIN_IN_ANALOGICO = 0b0000,
  PIN_IN_FLOTANTE  = 0b0100,
  PIN_IN_CON_PULL  = 0b1000,
  PIN_OUT_LENTO  = 0b0010,
  PIN_OUT_MEDIO  = 0b0001,
  PIN_OUT_RAPIDO   = 0b0011,
  PIN_OUT_OD_LENTO = 0b0110,
  PIN_OUT_OD_MEDIO = 0b0101,
  PIN_OUT_OD_RAPIDO= 0b0111,
  PIN_AFO_LENTO  = 0b1010,
  PIN_AFO_MEDIO  = 0b1001,
  PIN_AFO_RAPIDO   = 0b1011,
  PIN_AFO_OD_LENTO = 0b1110,
  PIN_AFO_OD_MEDIO = 0b1101,
  PIN_AFO_OD_RAPIDO= 0b1111
} ModoEntrada;
```

::: callout
Identificador `ModoEntada` → *`ModoEntrada` es...*\
Izquierda: `typedef enum {...}` → *un tipo definido por el usuario, equivalente a la enumeración anónima especificada (además, se definen las correspondientes constantes).*
:::

## Inicializadores de arreglos y estructuras

``` c
typedef struct MiStruct {int a;int b;int c;} MiStruct;
typedef union MiUnion {char b[4];short h[2];long w;} MiUnion;
// Lista de inicialización
int arreglo_1[] = {1,2,3,4};  // Toma la dimensión de la lista
int arreglo_2[8] = {1,2,3,4}; // Los miembros no especificados se inicializan en 0
int arreglo_3[][3] = {{1,2},{1,3,4}}; // Solo puede omitirse la primera dimensión
char arreglo4[] = "ABC"; // equivale a {'A','B','C','0'}
MiStruct estructura_1 = {3,5,7}; // a=3, b=5, c=7
MiStruct estructura_2 = {1};   // a=1, b=0, c=0
MiUnion  union_1 = {{1,2,3,4}};  // En una unión solo puede inicializarse así el primer miembro
// Inicializador con designación
// inicializa {3,4,0,0,0,23,24,0,-4,0,0,0,0,0,0}
int arreglo_5[15] = {[5]=23,24,[8]=-4,[0]=3,4};
// inicializa {{0,0},{1,2},{0,0}}
int arreglo_6[3][2] = {[1]={1,2}};
// inicializa {{1,0},{0,0},{0,2}}
int arreglo_7[3][2] = {[0][0]=1,[2][1]=2};
MiStruct estructura_3 = {.b=3,.a=-2}; // a=-2, b=3, c=0
// Única manera de inicializar un miembro de una union que no sea el primero
// w es -7
MiUnion union_2 = {.w=-7};
// h es {0,4}
MiUnion union_3 = {.h[1]=4};
// b es {0,0,5,7}
MiUnion union_4 = {.b={[2]=5,7}};
```

## Literales compuestos

Los literales compuestos crean objetos de tipo estructura, unión o arreglo. Para crearlos se especifica el tipo entre paréntesis y se ubica a continuación un inicializador con designación.

::: callout-warning
Los objetos creados por los literales compuestos **solo son válidos en el ámbito donde fueron creados**. Corresponden a variables automáticas anónimas si fueron creados dentro de un bloque de código y variables static si fueron creados en el ámbito de archivo (fuera de una función). En particular no se debe retornar nunca la dirección de un objeto automático (variable local), pues la memoria es liberada al salir del bloque donde fue reservada. Lo que sí se puede retornar es **el valor** de un literal compuesto tipo estructura o unión.
:::

``` c
#include <assert.h>
typedef struct {char nombre[20];char apellido[20];int edad;} Ficha;
int posicion_maximo(int n,int const *b);
// Muestra la ficha por pantalla. La dirección de memoria pasada
// no es almacenada de forma permanente en ningún lugar.
void muestra_ficha(Ficha const *ficha);
typedef struct Vec2D {int x;int y;} Vec2D;
Vec2D ejemplo(void){
  int i;
  // Equivale a crear una variable local tipo arreglo a 8 enteros, inicializada con {[3]=5,6,4} 
  // y pasarla como parámetro a posicion_maximo
  i = posicion_maximo(8,(int[8]){[3]=5,6,4});
  assert(4 == i);
  // Equivale a crear una variable local de solo lectura de tipo Ficha, inicializada con el
  // inicializador designado {...}, y pasar su dirección como argumento a muestra_ficha.
  // NOTA: La dirección de memoria se volverá inválida al salir de main (pues la memoria es liberada)
  // Por lo tanto, muestra_ficha *NO PUEDE ALMACENAR EN NINGUN LADO LA DIRECCION DE MEMORIA PASADA*
  // Esta acción es, por lo tanto, INSEGURA. Si muestra_ficha guardara la dirección por ejemplo en una
  // variable estáticoa, eso sería un puntero inválido (llamado dangling pointer)
  muestra_ficha(&(Ficha const){
    .nombre = "Juan",
    .apellido = "Perez",
    .edad = 20});
  // Equivale a crear una variable Vec2D local y
  // retornar su VALOR. Es por lo tanto correcto (no
  // retorna la dirección de memoria sino el valor).
  // Se sugiere usar esto solo cuando es absolutamente
  // claro.
  return (Vec2D){5,3};
}
```

## Expresiones

De la misma forma que en matemática, en C una expresión es una secuencia de operadores y operandos que indica un cómputo. Ahora bien, en C las operaciones pueden tener efectos secundarios y produce un valor que tiene un tipo y pertenece a una categoría de valor.

::: callout-note
Las categorías de valor son:

-   Objetos en memoria, llamados `lvalue` (viene de *left value*, valor izquierdo, por razones históricas). Pueden ser de solo lectura o modificables (usando operadores de asignación, asignación compuesta o incremento).
-   Valores (llamados `rvalue`), son los valores suceptibles de almacenarse en memoria (en un `lvalue` modificable, mediante operador de asignación), pasarse como argumentos, usarse para efectuar una decisión en una estructura de control o descartarse. Un caso especial de rvalue es el de tipo `void`, que significa que no hay un valor (y no puede hacerse de el ningún uso salvo descartarlo).
-   Designadores de función. A esta categoría pertenece un identificador que designa una función.
:::

## Paréntesis de agrupamiento

Las expresiones entre paréntesis son evaluadas en primer lugar. Los paréntesis de agrupamiento pueden identificarse pues ocupan el lugar que ocuparía un operando (un número, por ejemplo). Usar paréntesis explícitos siempre que no sea absolutamente claro el orden de operaciones.

``` c
int main(void){
  return (3+7)*(8-4)+(1 << (3+2));
}
```

## Operadores unarios

Los operadores unarios tienen un solo operando. Pueden ubicarse a la derecha del operando (sufijos) o a su izquierda (prefijos).

``` c
int f1(int a,int b){
  // '-' en este contexto es el
  // operador unario prefijo
  // negativo (complemento a 2)
  return -a * -b;
}
typedef struct Pila{
  int mem[128];
  int sp;
}Pila;
void push(int valor,Pila * pila){
  assert(pila->sp>0);
  // '--' es el operador unario
  // Post-incremento
  pila->mem[pila->sp--]=valor;  
}
```

## Operadores binarios

Los operadores binarios se ubican en medio de sus operandos.

``` c
struct s1{int a,int b};
int suma(struct s1 args){
  // '.' es el operador binario
  // acceso a miembro.
  // '+' es el operador binario
  // suma.
  return args.a+args.b;
}
```

## Precedencia

La precedencia indica el orden en el que se realizan las operaciones, por ejemplo el producto se realiza antes de la suma. En C hay 15 niveles de precedencia.

::: callout-caution
Algunas reglas de precedencia de C se prestan a confusión. En esos casos es **muy recomendable** usar paréntesis para indicar explícitamente el orden de operaciones.
:::

## Asociatividad

La asociatividad indica como se procesan varios operadores de la misma precedencia. Puede ser izquierda a derecha o derecha a izquierda.

::: callout-caution
La asociatividad puede a veces no ser intuitiva. Se recomienda usar paréntesis para indicar el orden de operación siempre que no sea inmediatamente claro.
:::

### Izquierda a derecha

Si hay tres o más operandos, se procesan primero las operaciones a la izquierda.

``` c
#include <stdio.h>
#include <assert.h>
int main(void){
  int a,b;
  a = 7*2/3*5;
  // equivale a 
  b = ((7*2)/3)*5;
  assert(a == b);
  puts("No falla\n");
  return 0;
}
```

### Derecha a izquierda

Si hay tres o más operandos, se procesan primero las operaciones a la derecha.

``` c
#include <stdio.h>
#include <assert.h>
int main(void){
  int a1=8,b1,c1;
  int a2=8,b2,c2;
  c1=a1+=b1=5;
  c2=(a2+=(b2=5));
  assert((a1==a2)&&(b1==b2)&&(c1==c2));
  printf("a: %d, b: %d, c: %d\n",a1,b1,c1); // a: 13, b: 5, c: 13
  return 0;
}
```

## Operadores de precedencia 1

Son los operadores de post-incremento, post-decremento, llamado a función, direccionamiento de arreglo, acceso a miembro, acceso a miembro por puntero y literal compuesto. Se ejecutan antes que cualquier otro operador (excepto agrupación con paréntesis).

### 

::: callout-note
La asociatividad de estos operadores es de ***izquierda a derecha***.
:::

``` c
#include <stdio.h>
#include <assert.h>

typedef struct Nodo Nodo;
struct Nodo {
  int valor;
  Nodo *izq;
  Nodo *der;
};
int main(void){
  int x=0,y=3,u,v;
  Nodo nodos[4]={0}, *pnodo;
  // Post incremento/post decremento
  u = x++;
  v = y--;
  // Llamado a función
  printf("x: %d, y: %d, u: %d, v: %d",x,y,u,v);
  assert((x == 1) && (y == 2) && (u == 0) && (v == 3));
  // Indexado, literal compuesto
  nodos[0]=(Nodo){.valor=x};
  nodos[1]=(Nodo){.valor=y};
  // Indexado, acceso a miembro
  nodos[2].valor=u;
  nodos[3].valor=v;
  pnodo = &nodos[3];
  // Acceso a miembro por puntero
  pnodo->izq = &nodos[0];
  pnodo->izq->izq = &nodos[2];
  pnodo->izq->der = &nodos[1];
  assert(pnodo->izq->valor < pnodo->valor);
  assert(pnodo->izq->izq->valor < pnodo->izq->valor);
  assert(pnodo->izq->valor < pnodo->izq->der->valor);
  return 0;
}
```

## Operadores de precedencia 2

Son operadores de pre-incremento, pre-decremento, signos positivo y negativo, NOT booleano, NOT bit a bit, conversión de tipo, indirección (acceso al destino de un puntero), dirección (dirección de memoria de un objeto) y sizeof (tamaño de un objeto).

::: callout-note
La asociatividad de estos operadores es de ***derecha a izquierda***.
:::

``` c
#include <assert.h>
#include <stdint.h>
int main(void){
  int x=0,y=3,u,v;
  int a,b,c;
  uint16_t d;
  int *p1, *p2, **p3;
  // Pre incremento/post decremento
  u = ++x;
  v = --y;
  assert((u == x) && (v == y));
  // Positivo y negativo
  // NOTAR LOS ESPACIOS...
  a = - - 3;
  b = + - 3;
  assert(a == -b);
  // NO lógico (booleano)
  c = !!4;
  assert(c == 1);
  // No bit a bit, conversión de tipo
  d = (uint16_t)~0xF00FU;
  assert(d == (uint16_t)0x0FF0U);
  // operador dirección de...
  p1 = &a;
  p2 = &b;
  // operador indirección (contenido de...)
  *p1 = -9;
  assert((a == -9) && (*p2 == -3));
  // operador sizeof (tamaño de)
  assert(sizeof d == 2 );
  p3 = &p2;
  assert(**p3 == -3);
  return 0;
}
```
